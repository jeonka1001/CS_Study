# 면접준비 - DataBase
> 나만의 언어로 준비하는 면접준비

## 목록
- [SELECT](#select)
- [DDL, DML, DCL](#ddl-dml-dcl)
- [트랜잭션](#트랜잭션)
- [PK vs FK](#pk-vs-fk)
- [인덱스](#인덱스)
- [join](#join)
- [정규화](#정규화)

----
## 데이터 베이스 사용 이유
> 데이터의 독립성, 무결성 

## Connection Pool
- 데이터베이스 접근 시 필요한 Connection 을 미리 생성하여 담아두는 곳
- 미리 생성한 것을 꺼내서 사용 후 반환하는 기법을 사용

###### connection 이 부족하면?
- 해당 요청은 대기상태로 전환되며, 사용 가능한 
connection 이 반환될 시 순차적으로 진행된다.

###### 사용 이유 ? 
- 미리 생성하기 때문에 생성 시간을 줄일 수 있다.
- 개수 제한을 하기 때문에 메모리와 db에 걸리는 부하를 조정할 수 있다.

---
## SELECT
> 데이터 베이스에 데이터 요청 시 작성하는 명령어
#### SELECT 문법 순서
- select 쿼리를 작성하는 방법은 다음과 같다.
- ```select``` ```from``` ```where``` ```group by``` ```having``` ```order by```
#### SELECT 실행 순서
- select 쿼리가 실행되는 순서는 다음과 같다.
- ```from``` ```where``` ```group by``` ```having``` ```select``` ```order by```
1. 원하는 테이블에 접근
2. 원하는 조건만 가져옴
3. 원하는 기준으로 그룹을 묶음
4. 그룹 중 조건에 맞는 것만 선택
5. 뽑아온다
6. 정렬하여 출력


## DDL DML DCL
- DDL(database define language)
    - 데이터 베이스 정의어
    - 데이터 베이스에 데이터 구조를 정의하는 명령어
    - create, alter, drop, rename,truncate 등이 있다
- DML ( database manipulation language)
    - 데이터 베이스 조작어 ( CURD )
    - 데이터 베이스의 데이터를 조작하는 명령어
    - insert update delete select 등
- DCL ( database control language)
    - 데이터 베이스 제어어
    - 데이터 베이스에 권한을 주고 수거하는 명령어
    - grant revoke

#### delete vs truncate vs drop
||delete|truncate|drop|
|--|--|--|--|
|테이블|존재|존재|삭제|
|저장공간|유지|반납|반납|
|되돌리기|가능|불가능|불가능|
|구문 종류|DML|DDL|DDL|
|부분삭제|가능|불가능|불가능|
- delete 의 경우 rollback 을 대비해 log 를 남기고 데이터를 삭제하므로 truncate 가 성능이 더 좋다.
- delete 로 삭제한 데이터의 경우 timestamp로 복구할 수 있다.
---

## 트랜잭션
> 한꺼번에 수행되어야 할 연산의 단위
- 여러개의 쿼리가 하나의 트랜잭션이라 할 수 있으며, 하나의 쿼리 또한 트랜잭션이라 할 수 있다.
- 트랜잭션이 정상적으로 완료되었을 시 commit 하여 DB에 반영하고, 도중에 문제가 있었을 시 rollback 하여 이전 상태로 되돌립니다.

### ACID
- **A** ( atomicity ) 원자성
    - 트랜잭션 연산은 DB에 모두 반영되거나 반영되지 않아야 한다.
- **C** ( consistency ) 일관성
    - 시스템이 가진 고정 요소는 트랜잭선 수행 전,후 가 같아야 한다.
    - 트랜잭션 성공 후 일관성 있는 상태로 DB를 유지해야 한다.
- **I** ( Isolation ) 독립성
    - 둘 이상의 트랜잭션이 진랭되는 경우 하나의 트랜잭션이 다른 하나에 끼어들 수 없다.
    - 수행중인 트랜잭션의 값을 다른 트랜잭션이 참조할 수 없다
- **D** ( Durablility ) 지속성 
    - 성공적으로 수행된 트랜잭션 결과는 영구적으로 반영되어야 한다.

#### 동시성 제어
> 데이터 베이스의 일관성과 독립성을 유지하기 위해 동시성을 제어한다.
- 둘 이상의 트랜잭션이 하나의 자원에 접근할 때 이를 제어함
- 발생 할 수 있는 문제점
    1. 읽기 & 쓰기 : 오손읽기, 유령 데이터 읽기, 반복 불가능 읽기
    2. 쓰기 & 쓰기 : 갱신 손실, 모순성, 연쇄 복구
#### 트랜잭션 격리 수준
- 동시에 여러 트랜잭션을 처리할 시 특정 트랜잭션이 다른 트랜잭션이 변경, 조회 하는 테이블을 보는 것을 허용 할지 말지 결정하는 것
- ```READ UNCOMMITED``` , ```READ COMMITED``` , ```REPEATABLE READ``` , ```SERIALIZABLE```

###### READ UNCOMMITED
- commit 혹은 rollback 여부에 상관 없이 조회 가능한 수준
- 이 경우 T2 가 읽은 작업이 T1에 의해 rollback 되면 실제 값과 T2 가 읽은 값이 다를 수 있다.
###### READ COMMITED 
- commit 이 완료된 트랜잭션의 변경사항만 다른 트랜잭셔에서 조회 가능.
- 이 경우 작업 진행중인 T2 가 다시 이 전과 같은 select 문을 수행한다면 값이 달라질 수 있다.
###### REPEATABLE READ 
> InnoDB 의 기본 격리 수준이다.  
- 트랜잭션 시작을 기준으로 아이디를 부여하며 아이디가 낮은 트랜잭션에서 변경한 것만 읽히게 한다.
- 1개 데이터 조회 시 문제가 발생하지 않는다.
- 여러 건의 데이터 조회 시 없던 데이터( 높은 아이디의 트랜잭션이 insert 한 데이터 )가 갑자기 생길 수 있다.
###### SERIALIZABLE READ
- 선행 트랜잭션이 작업을 완료하기 전까지 후행 트랜잭션은 해당 테이블에 어떠한 작업도 할 수 없는 것

---
## PK vs UK
- 두 속성 모두 해당 컬럼을 중복되지 않게 해준다는 공통점이 있다. 그러나 차이점은 ?  

||PK|UK|
|--|--|--|
|NULL|불가|허용|
|참조무결성|가능|불가능|
|지정 개수|1개만|여러개 가능|
|클러스터 인덱스|사용|사용하지않음|
**클러스터 인덱스** : 입력된 데이터를 클러스터 인덱스를 통해 물리적으로 재배열 한다.

---

## 인덱스 
- 테이블의 데이터 검색 속도를 높여주는 자료구조
- 기존 데이터를 조회하기 위해서는 테이블을 full scan 하며 데이터를 조회한다.
- 인덱스는 모든 페이지를 full scan 하지 않고, 찾고자 하는 인덱스의 자식 노드로 수직 스캔해서 리프노드가 나올 시 해당 리프 노드를 range scan 하는 방식으로 스캔한다.

#### full scan vs range scan
- full scan 
    - 인덱스 리프 노드를 처음부터 끝까지 스캔하는 방식
    - multi block i/o 가 이루어 진다.
- range scan 
    - 찾고자 하는 데이터가 있는 범위의 리프 노드만 스캔하며 찾은 방식
    - single block i/o 가 이루어 진다.
- 즉, 인접한 여러개의 데이터를 찾을 시 ```full scan``` 이 적합하며, 특정 조건에 맞는 소수의 데이터를 찾는 경우 ```range scan``` 이 적합하다.


#### Index가 사용하는 자료구조 B-Tree
- 자식 노드의 개수가 2개 이상인 트리
- 인덱스의 컬럼과 이에 해당하는 데이터가 들어있는 페이지 주소를 같이 저장한 후 자식 노드로 해당 페이지를 가리킨다.
- 실제 데이터가 들어있는 페이지는 리프노드이다.
- 따라서 실제 데이터를 꺼낼 시 리프노드에서 꺼내온다.

---

## Join
> 여러 테이블에 흩어진 정보 중 사용자가 필요한 정보만 조합해 가져오는 연산
- 종류 : outer join, inner join, cross join, self join 

#### outer join
- left, right, full outer join 이 있다.
- 각 키워드별 기준 테이블을 잡고 join을 하는 테이블과 기준 테이블의 공통 데이터와, 기준 테이블에만 있는 데이터를 join 조합한다.
- 기준 테이블에만 있고 다른 테이블에 없는 경우 해당 컬럼을 null 값으로 조합한다.

#### inner join 
- 두 테이블이 완전히 곂치는 부분만 한다.
- 교집합과 같은 개념

#### cross join
- 각 테이블의 데이터를 한뻔식 교차하여 테이블을 합친다.

---

## 정규화
> 관계형 데이터 베이스에서 데이터 값의 중복을 최소화 하는 작업
- 정규화 작업의 종류로는 1,2,3 정규화가 있다.

#### 제1 정규화
- 테이블의 각 컬럼 값이 원자값으로 이루어져야 한다.  
- 모든 속성에 반복되는 그룹이 나타나지 않는다.
- 기본 키를 이용하여 모든 데이터를 고유하게 식별할 수 있어야 한다.

만약 아래와 같은 테이블이 있을 때 김수의 취미 컬럼 값은 원자값이 아니다.
|이름|취미|
|--|--|
|김철수|야구|
|김민수|농구,배구|
따라서 이 값을 아래와 같이 정규화 할 수 있다.
|이름|취미|
|--|--|
|김철수|야구|
|김민수|농구|
|김민수|배구|

#### 제2 정규화
- 제1 정규화를 만족해야한다.
- 기본키가 아닌 컬럼 값들은 기본키에 종속되어야 한다.
- 기본키가 복합키일 경우 이외 컬럼들은 복합키 모두에 종속외어야 한다.
    - 일부 기본키에만 종속 할 경우 이를 정규호 시켜 별도의 테이블로 분리한다.  

아래 책 대여 테이블이 기존 이런 상태라면
|<u>대여자</u>|<u>대여품목</u>|대여일자|장르|
|---|---|---|---|
|김민수|HX1001|2020-04-22|공포|
|김철수|US1051|2020-04-23|개그|
|홍길동|FA0901|2020-03-31|판타지|
대여일자는 PK 모두에 종속되지만, 장르는 대여품목에만 종속된다.
따라서 이를 분리해야한다.  

|<u>대여자</u>|<u>대여품목</u>|대여일자|       
|---|---|---|              
|김민수|HX1001|2020-04-22|
|김철수|US1051|2020-04-23|
|홍길동|FA0901|2020-03-31|

|<u>대여품목</u>|장르|
|---|---|
|HX1001|공포|
|US1051|개그|
|FA0901|판타지|

다음과 같이 분리하면 제2 정규화에 만족한다.

#### 제3 정규화
- 제2 정규화를 만족한다.
- 일반 컬럼이 다른 일반 컬럼에의해 종속성을 가지면 안된다. 
    - 이 경우 다른 테이블로 분리한다.

만약 2 정규화를 마친 테이블의 상태가 아래와 같다 하자.
**A대학의 학생 정보 테이블**
|<u>학번</u>|이름|단과대학|학과|
|---|---|---|---|
|20151111|이순신|생명대학|해양생물학과|
|20161111|홍길동|체육대학|생활체육학과|

이 경우 모든 일반 속성은 기본키에 종속된다. 그러나 학과 또한 단과대학에 종속된다.  
따라서 **제3정규화** 에 의해 아래와 같이 테이블을 분리할 수 있다.

|<u>학번</u>|이름|학과|
|---|---|---|---|
|20151111|이순신|해양생물학과|
|20161111|홍길동|생활체육학과|

|<u>학과</u>|단과대학|
|---|---|
|해양생물학과|생명대학|
|생활체육학과|체육대학|

---

## 반 정규화
> 테이블 반정규화,컬럼 반 정규화, 관계 반 정규화 가 있다.
- 테이블의 데이터 무결성이 자동으로 보장되지 않고 개발자가 일일이 신경써야 한다.
#### 테이블 반정규화
> 테이블 ( 병합 / 분할 / 추가 )
- 테이블 병합 
    - 비즈니스 로직 상 join 경우가 많아 성능 저하가 고려될 경우 행해진다.
- 테이블 분할
    - 수평방식, 수직방식
- 테이블 추가
    - 중복 테이블 추가 : 원격 조인을 방지하기 위해 타 서버의 테이블을 그대로 추가
    - 통계 테이블 추가 : 통계값을 미리 계산해서 테이블을 추가
    - 이력 테이블 추가 : 트랜잭션 발생 시점에 따라 복사해 두는 테이블 추가
    - 부분 테이블 추가 : 자주 조회되는 컬럼을 별도로 모아둔 테이블
#### 컬럼 반 정규화
> ( 중복 / 파생 / 이력테이블 )컬럼 추가
- 중복 컬럼 추가
    - 이미 있는 컬럼을 다른 테이블에 다시 추가하는 것
    - select 비용은 감소하나 update 비용이 
    증가한다.
    - ex ) 회원테이블의 회원번호컬럼 - 배송 테이블의 회원번호 컬럼
- 파생 컬럼 추가
    -  계산을 통해 얻어지는 값을 컬럼으로 추가하는 것
    - ex ) 주문상품 테이블의 수량 컬럼 * 상품 테이블의 단가 컬럼 = 주문 총액 - 주문 총액을 주문 테이블에 추가
- 이력 테이블 컬럼 추가
    - 이력 테이블에 변경여부, 시작일, 종료일 등을 추가
    - 이력 테이블을 통해 변경여부가 true 인 경우 파생 컬럼을 업데이트 한다.
#### 관계 반정규화
- 중복 관계 추가 :

---

## PreparedStatement vs Statement
> 가장 큰 차이는 캐싱 여부  
- PreparedStatement
    - 컴파일 과정을 최초 1번만 수행(이후는 캐싱)하기 때문에 성능이 좋고, 쿼리가 코드상 ? 로 표기되기 때문에 보안이 상대적 좋다.
    - 쿼리의 조건절이 고정적이고, 반복 작업일 경우 좋다.

- Statement 
    - 매번 컴파일을 하며 쿼리가 코드 상 그대로 드러나기 때문에 보안이 좋지 않다.
    - 쿼리의 조건절이 매번 잘라지는 경우 좋다.

---

## sql injection
- 악의적인 sql 문을 실행하게 하여 데이터베이스의 정보를 조작하는 해킹 기법
- 주로 동적 쿼리를 생성하는 기능에서 많이 발생

#### 해결 방안
- 입력값 검증
    - 사용작에게 전달받은 값이 개발자가 의도한 값인지 검증
    - 쿼리의 지정된 형식(틀)을 사용하며 전달인자를 끼워넣는 방식으로 수행한다.

---

## Replication
> 데이터 베이스를 복제하는 것
- 같은 데이터베이스를 복제하여 master, slave 로 나누어 사용하는 것
- master 에서는 insert, update, delete 를 수행하며, slave 에서는 select 를 수행하여 쿼리를 분산시킨다.
- master 에서 데이터 조작이 이루어 지면, 이를 slave에 반영한다.

---

## 파티셔닝
> 크기가 큰 테이블을 작은 단위로 분할하여 관리하는 것

## 장점 
- full scan에서 scan 범위를 줄여 성능을 가져온다.
- 각 분할 영역별로 독립적으로 백업/복구를 수행할 수 있다.
- DML 쿼리의 성능을 높혀준다.

## 단점
- join 비용이 증가한다

## 종류 
- 수평분할, 수직분할

---

## ORM 
> Object Relational Mapping
- 객체와 데이터베이스 테이블을 연결해주는 것
#### JPA
- 장점
    - 코드의 간결성 ( 비즈니스 로직 외 부수적인 코드가 줄어든다 )
    - 유지보수(이식성)가 좋다 ( 독립적으로 작성되었기 때문에 쿼리 수정 시 해당 쿼리 사용 객체를 수정하지 않아도 됨 )

- 단점
    - 자주 사용되는 대형 쿼리는 속도를 위해 SP 등 별도의 튜닝이 필요하다
    - 

---

## 옵티마이저


---

## View
- 사용자에게 허용된 자료만 제한적을 보여주기 위한 하나 이상의 기본 테이블로 유도된 가상 테이블
- 저장장치 내에 물리적으로 존재하지않음.

#### 장점
- Join 문 최소화
- 데이터 접근 제어를 통한 보안 제공
- 동일 테이블에 대해 동시 여러 사용자의 요구 지원

## 단점
- 독립적인 인덱스 보유 불가
- 뷰 의 정의를 변경할 수 없다.
- 구성된 내용에 대해 삽입,삭제,수정 작업은 제약이 따른다. 

---
## vs NoSQL
> Document Graph Key-Value

- Document : json document 형대로 저장 어떤 종류의 어떤 형태 모양으로든 저장할 수 있다.
- MongoDB 사용 이유 ? 
어떠헌 챔피언이나 어떠한 아이템이나 아떠한 룰이 생성될지 모르기 때문에 몽고디비를 사용했다.

- Key-Value : 읽기와 쓰기가 정말 빠르다
    - 저장하기 전에 어떻게 저장할 지 선택해야한다.
- Graph : 데이터의 형태가 중요하지 않지만 각 데이터의 관계가 중요할 때 사용

---

## vs 오라클
- 대규모 트랜잭션 처리 가능, 성능 최적화를 위해 여러 서버에 대용량 DB 분산
- MySQL 는 단일 데이터 베이스로 제한되어 있음


---

## UML ( unified Modeling Language )
- 프로그램 설계를 표현하기 위해 사용하는 표기법으로 주로 그림으로 표현한다.
- 객체지향 언어와 밀접한 관련이 있기 때문에 객체지향 모델링 언어라 하기도 함

---
