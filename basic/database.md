# 면접준비 - DataBase
> 나만의 언어로 준비하는 면접준비

## 목록
- [Table Engine](#table-engine)
- [SELECT](#select)
- [DDL, DML, DCL](#ddl-dml-dcl)
- [트랜잭션](#트랜잭션)
- [PK vs FK](#pk-vs-fk)
- [인덱스](#인덱스)
- [join](#join)
- [정규화](#정규화)

----

## table engine
> innodb, memory, archive, csv 등
- 데이터 베이스 테이블의 스토리지 엔진 종류
#### innodb
- 가장 많이 사용되는 storage engine
- 트랜잭션이 대부분 롤백되지않고 완료되는 짧은 트랜잭션을 많이 처리해야할 때 좋음.
- 
#### memory

#### archive

#### csv



---
## SELECT
> 데이터 베이스에 데이터 요청 시 작성하는 명령어
#### SELECT 문법 순서
- select 쿼리를 작성하는 방법은 다음과 같다.
- ```select``` ```from``` ```where``` ```group by``` ```having``` ```order by```
#### SELECT 실행 순서
- select 쿼리가 실행되는 순서는 다음과 같다.
- ```from``` ```where``` ```group by``` ```having``` ```select``` ```order by```
1. 원하는 테이블에 접근
2. 원하는 조건만 가져옴
3. 원하는 기준으로 그룹을 묶음
4. 그룹 중 조건에 맞는 것만 선택
5. 뽑아온다
6. 정렬하여 출력


## DDL DML DCL
- DDL(database define language)
    - 데이터 베이스 정의어
    - 데이터 베이스에 데이터 구조를 정의하는 명령어
    - create, alter, drop, rename,truncate 등이 있다
- DML ( database manipulation language)
    - 데이터 베이스 조작어 ( CURD )
    - 데이터 베이스의 데이터를 조작하는 명령어
    - insert update delete select 등
- DCL ( database control language)
    - 데이터 베이스 제어어
    - 데이터 베이스에 권한을 주고 수거하는 명령어
    - grant revoke

#### delete vs truncate vs drop
||delete|truncate|drop|
|--|--|--|--|
|테이블|존재|존재|삭제|
|저장공간|유지|반납|반납|
|되돌리기|가능|불가능|불가능|
|구문 종류|DML|DDL|DDL|
|부분삭제|가능|불가능|불가능|

---

## 트랜잭션
> 한꺼번에 수행되어야 할 연산의 단위
- 여러개의 쿼리가 하나의 트랜잭션이라 할 수 있으며, 하나의 쿼리 또한 트랜잭션이라 할 수 있다.
- 트랜잭션이 정상적으로 완료되었을 시 commit 하여 DB에 반영하고, 도중에 문제가 있었을 시 rollback 하여 이전 상태로 되돌립니다.

### ACID
- **A** ( atomicity ) 원자성
    - 트랜잭션 연산은 DB에 모두 반영되거나 반영되지 않아야 한다.
- **C** ( consistency ) 일관성
    - 시스템이 가진 고정 요소는 트랜잭선 수행 전,후 가 같아야 한다.
    - 트랜잭션 성공 후 일관성 있는 상태로 DB를 유지해야 한다.
- **I** ( Isolation ) 독립성
    - 둘 이상의 트랜잭션이 진랭되는 경우 하나의 트랜잭션이 다른 하나에 끼어들 수 없다.
    - 수행중인 트랜잭션의 값을 다른 트랜잭션이 참조할 수 없다
- **D** ( Durablility ) 지속성 
    - 성공적으로 수행된 트랜잭션 결과는 영구적으로 반영되어야 한다.

#### 동시성 제어
> 데이터 베이스의 일관성과 독립성을 유지하기 위해 동시성을 제어한다.
- 둘 이상의 트랜잭션이 하나의 자원에 접근할 때 이를 제어함
- 발생 할 수 있는 문제점
    1. 읽기 & 쓰기 : 오손읽기, 유령 데이터 읽기, 반복 불가능 읽기
    2. 쓰기 & 쓰기 : 갱신 손실, 모순성, 연쇄 복구
#### 트랜잭션 격리 수준
- 동시에 여러 트랜잭션을 처리할 시 특정 트랜잭션이 다른 트랜잭션이 변경, 조회 하는 테이블을 보는 것을 허용 할지 말지 결정하는 것
- ```READ UNCOMMITED``` , ```READ COMMITED``` , ```REPEATABLE READ``` , ```SERIALIZABLE```

###### READ UNCOMMITED
- commit 혹은 rollback 여부에 상관 없이 조회 가능한 수준
- 이 경우 T2 가 읽은 작업이 T1에 의해 rollback 되면 실제 값과 T2 가 읽은 값이 다를 수 있다.
###### READ COMMITED 
- undo 영역에 있는 데이터를 가져와 읽는것이 가능함. 즉, 해당 테이블에 트랜잭션이 진행중이면 작업 전 데이터를 읽는다.
- 이 경우 작업 진행중인 T2 가 다시 이 전과 같은 select 문을 수행한다면 값이 달라질 수 있다.
###### REPEATABLE READ 
> InnoDB 의 기본 격리 수준이다.  
- 트랜잭션 시작을 기준으로 아이디를 부여하며 아이디가 낮은 트랜잭션에서 변경한 것만 읽히게 한다.
- 1개 데이터 조회 시 문제가 발생하지 않는다.
- 여러 건의 데이터 조회 시 없던 데이터( 높은 아이디의 트랜잭션이 insert 한 데이터 )가 갑자기 생길 수 있다.
###### SERIALIZABLE READ
- 선행 트랜잭션이 작업을 완료하기 전까지 후행 트랜잭션은 해당 테이블에 어떠한 작업도 할 수 없는 것
- lock 과 비슷한 개념이라 생각하면 된다.

---
## PK vs UK
- 두 속성 모두 해당 컬럼을 중복되지 않게 해준다는 공통점이 있다. 그러나 차이점은 ?  

||PK|UK|
|--|--|--|
|NULL|불가|허용|
|참조무결성|가능|불가능|
|지정 개수|1개만|여러개 가능|
|클러스터 인덱스|사용|사용하지않음|
**클러스터 인덱스** : 입력된 데이터를 클러스터 인덱스를 통해 물리적으로 재배열 한다.

---

## 인덱스 
- 테이블의 데이터 검색 속도를 높여주는 자료구조
- 기존 데이터를 조회하기 위해서는 테이블을 full scan 하며 데이터를 조회한다.
- 인덱스는 모든 페이지를 full scan 하지 않고, 찾고자 하는 인덱스의 자식 노드로 수직 스캔해서 리프노드가 나올 시 해당 리프 노드를 range scan 하는 방식으로 스캔한다.

#### full scan vs range scan
- full scan 
    - 인덱스 리프 노드를 처음부터 끝까지 스캔하는 방식
    - multi block i/o 가 이루어 진다.
- range scan 
    - 찾고자 하는 데이터가 있는 범위의 리프 노드만 스캔하며 찾은 방식
    - single block i/o 가 이루어 진다.
- 즉, 인접한 여러개의 데이터를 찾을 시 ```full scan``` 이 적합하며, 특정 조건에 맞는 소수의 데이터를 찾는 경우 ```range scan``` 이 적합하다.


#### Index가 사용하는 자료구조 B-Tree
- 자식 노드의 개수가 2개 이상인 트리
- 인덱스의 컬럼과 이에 해당하는 데이터가 들어있는 페이지 주소를 같이 저장한 후 자식 노드로 해당 페이지를 가리킨다.
- 실제 데이터가 들어있는 페이지는 리프노드이다.
- 따라서 실제 데이터를 꺼낼 시 리프노드에서 꺼내온다.

## Join
> 여러 테이블에 흩어진 정보 중 사용자가 필요한 정보만 조합해 가져오는 연산
- 종류 : outer join, inner join, cross join, self join 

#### outer join
- left, right, full outer join 이 있다.
- 각 키워드별 기준 테이블을 잡고 join을 하는 테이블과 기준 테이블의 공통 데이터와, 기준 테이블에만 있는 데이터를 join 조합한다.
- 기준 테이블에만 있고 다른 테이블에 없는 경우 해당 컬럼을 null 값으로 조합한다.

#### inner join 
- 두 테이블이 완전히 곂치는 부분만 한다.
- 교집합과 같은 개념

#### cross join
- 각 테이블의 데이터를 한뻔식 교차하여 테이블을 합친다.

## 정규화
> 관계형 데이터 베이스에서 데이터 값의 중복을 최소화 하는 작업
- 정규화 작업의 종류로는 1,2,3 정규화가 있다.

#### 제1 정규화
- 테이블의 각 컬럼 값이 원자값으로 이루어져야 한다.  
- 모든 속성에 반복되는 그룹이 나타나지 않는다.
- 기본 키를 이용하여 모든 데이터를 고유하게 식별할 수 있어야 한다.

만약 아래와 같은 테이블이 있을 때 김수의 취미 컬럼 값은 원자값이 아니다.
|이름|취미|
|--|--|
|김철수|야구|
|김민수|농구,배구|
따라서 이 값을 아래와 같이 정규화 할 수 있다.
|이름|취미|
|--|--|
|김철수|야구|
|김민수|농구|
|김민수|배구|

#### 제2 정규화
- 제1 정규화를 만족해야한다.
- 기본키가 아닌 컬럼 값들은 기본키에 종속되어야 한다.
- 기본키가 복합키일 경우 이외 컬럼들은 복합키 모두에 종속외어야 한다.
    - 일부 기본키에만 종속 할 경우 이를 정규호 시켜 별도의 테이블로 분리한다.  

아래 책 대여 테이블이 기존 이런 상태라면
|<u>대여자</u>|<u>대여품목</u>|대여일자|장르|
|---|---|---|---|
|김민수|HX1001|2020-04-22|공포|
|김철수|US1051|2020-04-23|개그|
|홍길동|FA0901|2020-03-31|판타지|
대여일자는 PK 모두에 종속되지만, 장르는 대여품목에만 종속된다.
따라서 이를 분리해야한다.  

|<u>대여자</u>|<u>대여품목</u>|대여일자|       
|---|---|---|              
|김민수|HX1001|2020-04-22|
|김철수|US1051|2020-04-23|
|홍길동|FA0901|2020-03-31|

|<u>대여품목</u>|장르|
|---|---|
|HX1001|공포|
|US1051|개그|
|FA0901|판타지|

다음과 같이 분리하면 제2 정규화에 만족한다.

#### 제3 정규화
- 제2 정규화를 만족한다.
- 일반 컬럼이 다른 일반 컬럼에의해 종속성을 가지면 안된다. 
    - 이 경우 다른 테이블로 분리한다.

만약 2 정규화를 마친 테이블의 상태가 아래와 같다 하자.
**A대학의 학생 정보 테이블**
|<u>학번</u>|이름|단과대학|학과|
|---|---|---|---|
|20151111|이순신|생명대학|해양생물학과|
|20161111|홍길동|체육대학|생활체육학과|

이 경우 모든 일반 속성은 기본키에 종속된다. 그러나 학과 또한 단과대학에 종속된다.  
따라서 **제3정규화** 에 의해 아래와 같이 테이블을 분리할 수 있다.

|<u>학번</u>|이름|학과|
|---|---|---|---|
|20151111|이순신|해양생물학과|
|20161111|홍길동|생활체육학과|

|<u>학과</u>|단과대학|
|---|---|
|해양생물학과|생명대학|
|생활체육학과|체육대학|

## 반 정규화
> 테이블 반정규화,컬럼 반 정규화, 관계 반 정규화 가 있다.
- 테이블의 데이터 무결성이 자동으로 보장되지 않고 개발자가 일일이 신경써야 한다.
#### 테이블 반정규화
> 테이블 ( 병합 / 분할 / 추가 )
- 테이블 병합 
    - 비즈니스 로직 상 join 경우가 많아 성능 저하가 고려될 경우 행해진다.
- 테이블 분할
    - 수평방식, 수직방식
- 테이블 추가
    - 중복 테이블 추가 : 원격 조인을 방지하기 위해 타 서버의 테이블을 그대로 추가
    - 통계 테이블 추가 : 통계값을 미리 계산해서 테이블을 추가
    - 이력 테이블 추가 : 트랜잭션 발생 시점에 따라 복사해 두는 테이블 추가
    - 부분 테이블 추가 : 자주 조회되는 컬럼을 별도로 모아둔 테이블
#### 컬럼 반 정규화
> ( 중복 / 파생 / 이력테이블 )컬럼 추가
- 중복 컬럼 추가
    - 이미 있는 컬럼을 다른 테이블에 다시 추가하는 것
    - select 비용은 감소하나 update 비용이 
    증가한다.
    - ex ) 회원테이블의 회원번호컬럼 - 배송 테이블의 회원번호 컬럼
- 파생 컬럼 추가
    -  계산을 통해 얻어지는 값을 컬럼으로 추가하는 것
    - ex ) 주문상품 테이블의 수량 컬럼 * 상품 테이블의 단가 컬럼 = 주문 총액 - 주문 총액을 주문 테이블에 추가
- 이력 테이블 컬럼 추가
    - 이력 테이블에 변경여부, 시작일, 종료일 등을 추가
    - 이력 테이블을 통해 변경여부가 true 인 경우 파생 컬럼을 업데이트 한다.
#### 관계 반정규화
- 중복 관계 추가 :